{
  "name": "IOC Extraction - OpenSource LLM",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -180,
        -120
      ],
      "id": "fe9c3f38-6496-44c1-b4b1-7e64b1fce743",
      "name": "When clicking â€˜Execute workflowâ€™"
    },
    {
      "parameters": {
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        140,
        -300
      ],
      "id": "da84f338-e64d-4b4d-99a8-8f330451cfcf",
      "name": "HTTP Request",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "curlImport": "",
        "httpVariantWarning": "",
        "method": "GET",
        "url": "=https://www.virustotal.com/api/v3/domains/{{ $json.value }}",
        "": "",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "virusTotalApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {
          "allowUnauthorizedCerts": true
        },
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        -120
      ],
      "id": "c334fd0d-f66b-4246-a5f1-c5c105555242",
      "name": "VirusTotal HTTP Request",
      "alwaysOutputData": true,
      "extendsCredential": "virusTotalApi",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "curlImport": "",
        "httpVariantWarning": "",
        "method": "GET",
        "url": "=https://www.virustotal.com/api/v3/files/{{ $json.value }}",
        "": "",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "virusTotalApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {
          "allowUnauthorizedCerts": true
        },
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        20
      ],
      "id": "8baa9023-d232-4f96-9fc0-6ec52e558377",
      "name": "VirusTotal HTTP Request1",
      "alwaysOutputData": true,
      "extendsCredential": "virusTotalApi",
      "credentials": {
        "virusTotalApi": {
          "id": "4x9wdJqTt8OT8dte",
          "name": "VirusTotal account 3"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "curlImport": "",
        "httpVariantWarning": "",
        "method": "GET",
        "url": "=https://www.virustotal.com/api/v3/ip_addresses/{{ $json.value }}",
        "": "",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "virusTotalApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {
          "allowUnauthorizedCerts": false
        },
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        160
      ],
      "id": "11298ff3-da70-45db-84be-5259919417f4",
      "name": "VirusTotal HTTP Request2",
      "alwaysOutputData": true,
      "extendsCredential": "virusTotalApi",
      "credentials": {
        "virusTotalApi": {
          "id": "4x9wdJqTt8OT8dte",
          "name": "VirusTotal account 3"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "toText",
        "sourceProperty": "text",
        "binaryPropertyName": "Sigma Rule File",
        "options": {
          "fileName": "SigmaRules"
        }
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        1080,
        -320
      ],
      "id": "bbbd79ed-4cb0-49f9-9274-90948a28ec2e",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from bs4 import BeautifulSoup\n\n# ðŸ“ Section for user-pasted text\n# Paste your text between the triple quotes\nuser_input_text = r\"\"\"\n\"\"\"\n\ndef clean_html_to_text(html_content: str) -> str:\n    \"\"\"\n    Takes raw HTML or plain text and returns cleaned text content.\n    \"\"\"\n    if not html_content.strip():\n        return \"\"\n\n    # If it looks like plain text (no HTML tags), just normalize\n    if \"<\" not in html_content and \">\" not in html_content:\n        return \" \".join(html_content.split())\n\n    # Otherwise treat it as HTML\n    soup = BeautifulSoup(html_content, \"html.parser\")\n\n    # Remove scripts, styles, metadata, etc.\n    for tag in soup([\"script\", \"style\", \"noscript\", \"meta\", \"link\", \"head\"]):\n        tag.decompose()\n\n    # Extract visible text\n    text = soup.get_text(separator=\" \", strip=True)\n\n    return \" \".join(text.split())\n\nout_items = []\n\n# Always process user-pasted input (if provided)\nif user_input_text.strip() and \"Input text here\" not in user_input_text:\n    cleaned_text = clean_html_to_text(user_input_text)\n    out_items.append({\n        \"json\": {\n            \"source\": \"user_input\",\n            \"cleaned_text\": cleaned_text\n        }\n    })\n\n# Always process input from previous node\nfor item in items:  # n8n provides items automatically\n    raw_input = item[\"json\"].get(\"data\", \"\")\n    if raw_input:\n        cleaned_text = clean_html_to_text(raw_input)\n        out_items.append({\n            \"json\": {\n                \"source\": \"workflow_input\",\n                \"cleaned_text\": cleaned_text\n            }\n        })\n\nreturn out_items\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        -320
      ],
      "id": "5d527be2-6d90-48a8-b2d3-79d955f1f21e",
      "name": "Beautify HTLM/Raw User Input"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from bs4 import BeautifulSoup\nimport re\nimport ipaddress\n\n# Get HTML content from previous node\nhtml_content = (\n    items[0][\"json\"].get(\"body\")\n    or items[0][\"json\"].get(\"data\")\n    or items[0][\"json\"].get(\"html\")\n    or str(items[0][\"json\"])\n)\n\n# Parse HTML\nsoup = BeautifulSoup(html_content, \"html.parser\")\n\n# Remove <script> and <style>\nfor tag in soup([\"script\", \"style\"]):\n    tag.decompose()\n\n# Extract clean text\ntext_content = soup.get_text(separator=\"\\n\")\n\n# Normalize obfuscated [.] â†’ .\ntext_content = text_content.replace(\"[.]\", \".\")\n\n# Regex patterns\npatterns = {\n    \"ips\": r\"\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b\",\n    \"domains\": r\"\\b[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b\",\n    \"md5\": r\"\\b[a-fA-F0-9]{32}\\b\",\n    \"sha1\": r\"\\b[a-fA-F0-9]{40}\\b\",\n    \"sha256\": r\"\\b[a-fA-F0-9]{64}\\b\"\n}\n\ndef extract_all(pattern, text):\n    matches = re.findall(pattern, text)\n    return sorted(set(matches)) if matches else []\n\ndef is_public_ip(ip):\n    try:\n        return ipaddress.ip_address(ip).is_global\n    except ValueError:\n        return False\n\n# Extract IOCs\nips = [ip for ip in extract_all(patterns[\"ips\"], text_content) if is_public_ip(ip)]\ndomains = extract_all(patterns[\"domains\"], text_content)\nmd5 = extract_all(patterns[\"md5\"], text_content)\nsha1 = extract_all(patterns[\"sha1\"], text_content)\nsha256 = extract_all(patterns[\"sha256\"], text_content)\n\n# Return in structure expected by next node\nreturn {\n    \"ips\": ips,\n    \"domains\": domains,\n    \"hashes\": {\n        \"md5\": md5,\n        \"sha1\": sha1,\n        \"sha256\": sha256\n    },\n    \"clean_text_preview\": text_content[:500]\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        0
      ],
      "id": "ff0db02c-6b8d-4215-82ec-03c18ec414f6",
      "name": "IOC Pattern Extraction"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import re\n\n# Common file extensions that should not be treated as domains\nINVALID_TLDS = {\n    \"jpg\", \"jpeg\", \"png\", \"gif\", \"bmp\", \"svg\",\n    \"js\", \"css\", \"json\", \"xml\", \"txt\", \"pdf\",\n    \"exe\", \"dll\", \"bin\", \"dat\", \"zip\", \"rar\",\n    \"tar\", \"gz\", \"7z\", \"mp3\", \"mp4\", \"wav\", \"mov\"\n}\n\ndef is_valid_domain(domain: str) -> bool:\n    \"\"\"\n    Returns True if the string looks like a valid domain, False otherwise.\n    \"\"\"\n    # Lowercase and strip whitespace\n    domain = domain.strip().lower()\n    \n    # Basic domain regex (no protocol, no path)\n    pattern = re.compile(r\"^(?:[a-z0-9-]+\\.)+[a-z]{2,63}$\")\n    if not pattern.match(domain):\n        return False\n    \n    # Extract TLD and check it's not a file extension\n    tld = domain.split(\".\")[-1]\n    if tld in INVALID_TLDS:\n        return False\n    \n    return True\n\nresults = []\ndata = items[0][\"json\"]\n\nfor domain in data.get(\"domains\", []):\n    if is_valid_domain(domain):\n        results.append({\"json\": {\"type\": \"domain\", \"value\": domain}})\n\n# Keep other IOC types untouched\nfor ip in data.get(\"ips\", []):\n    results.append({\"json\": {\"type\": \"ip\", \"value\": ip}})\n\nfor md5 in data.get(\"hashes\", {}).get(\"md5\", []):\n    results.append({\"json\": {\"type\": \"hash\", \"subtype\": \"md5\", \"value\": md5}})\n\nfor sha1 in data.get(\"hashes\", {}).get(\"sha1\", []):\n    results.append({\"json\": {\"type\": \"hash\", \"subtype\": \"sha1\", \"value\": sha1}})\n\nfor sha256 in data.get(\"hashes\", {}).get(\"sha256\", []):\n    results.append({\"json\": {\"type\": \"hash\", \"subtype\": \"sha256\", \"value\": sha256}})\n\nreturn results\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        0
      ],
      "id": "90d0f4f6-2d96-4055-9dff-74c97b68f117",
      "name": "IOC CleanUp"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "domain",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "15bfe4db-31b8-49b7-8a98-89baac770ee4"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Domains"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a3d15d26-8595-46e7-a116-b8983f1d808f",
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "hash",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "File Hashes"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "79fece62-829e-4cc1-a79d-918a02c1dd6e",
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "ip",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "IPs"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1080,
        0
      ],
      "id": "91c75b6f-c24d-4b66-a05e-089e096b5066",
      "name": "Switch - Domains, File Hashes, IPs"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Input from previous node\ninput_items = items  # 'items' is provided automatically in n8n Python node\n\n# Prepare output\noutput_items = []\n\nfor item in input_items:\n    data = item.get(\"json\", {}).get(\"data\", {})\n    stats = data.get(\"attributes\", {}).get(\"last_analysis_stats\", {})\n\n    if stats.get(\"malicious\", 0) > 0 or stats.get(\"suspicious\", 0) > 0:\n        output_items.append({\n            \"json\": {\n                \"id\": data.get(\"id\"),\n                \"type\": data.get(\"type\"),\n                \"malicious\": stats.get(\"malicious\", 0),\n                \"suspicious\": stats.get(\"suspicious\", 0),\n                \"attributes\": data.get(\"attributes\", {})\n            }\n        })\n\nreturn output_items\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        -200
      ],
      "id": "a4818fa1-9e03-4c74-b2e3-a4f8052cb315",
      "name": "Domain Enrichment -  Malicious Output"
    },
    {
      "parameters": {
        "jsCode": "// Create an array to hold the filtered items\nconst filteredItems = [];\n\n// Loop over all input items\nfor (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const data = item.json.data;\n\n    // Check if last_analysis_stats exists under attributes\n    if (data.attributes && data.attributes.last_analysis_stats) {\n        const harmlessCount = data.attributes.last_analysis_stats.harmless ?? 1;\n\n        // Only keep items where harmless <= 0\n        if (harmlessCount <= 0) {\n            filteredItems.push(item);\n        }\n    }\n}\n\n// Return the filtered items\nreturn filteredItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        0
      ],
      "id": "b5b3751e-304f-416c-82e4-00b692ba98b6",
      "name": "File Hash Enrichment -  Malicious Output",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "// Create an array to hold the filtered items\nconst filteredItems = [];\n\n// Loop over all input items\nfor (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const data = item.json.data;\n\n    // Check if last_analysis_stats exists under attributes\n    if (data.attributes && data.attributes.last_analysis_stats) {\n        const maliciousCount = data.attributes.last_analysis_stats.harmless ?? 1;\n\n        // Only keep items where harmless <= 0\n        if (maliciousCount > 0) {\n            filteredItems.push(item);\n        }\n    }\n}\n\n// Return the filtered items\nreturn filteredItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        220
      ],
      "id": "09fb9b5f-7cd5-494e-a611-6e2ce8ed2407",
      "name": "IP Enrichment -  Malicious Output",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Extract all IDs from incoming items\nids = []\n\nfor item in items:\n    data = item.get(\"json\", {})\n    if \"id\" in data:\n        ids.append(data[\"id\"])\n\n# Generate queries if we have IDs\nif ids:\n    # ---------------------------\n    # Format for MDE (KQL)\n    id_list_kql = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    mde_query = f\"\"\"\nDeviceNetworkEvents\n| where RemoteUrl in ({id_list_kql})\n\"\"\"\n\n    # ---------------------------\n    # Format for CrowdStrike (Raptor)\n    id_list_crowdstrike = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    crowdstrike_query = f\"\"\"\n#event_simpleName=*DnsRequest*\n| in(field=DomainName, values=[{id_list_crowdstrike}])\n\"\"\"\n\n    # ---------------------------\n    # Format for Uptycs (SQL-like)\n    id_list_uptycs = \", \".join([f\"'{d}'\" for d in ids])\n    uptycs_query = f\"\"\"\nSELECT *\nFROM dns_lookup_events\nWHERE\nquestion IN ({id_list_uptycs})\nAND\nupt_day >= CAST(date_format((CURRENT_DATE - INTERVAL '14' DAY), '%Y%m%d') AS INT)\n\"\"\"\n\n    # Clean up queries (remove \\n, collapse into single lines)\n    mde_query = \" \".join(mde_query.split())\n    crowdstrike_query = \" \".join(crowdstrike_query.split())\n    uptycs_query = \" \".join(uptycs_query.split())\n\n    # Return queries back to n8n\n    return [{\n        \"json\": {\n            \"ids\": ids,\n            \"mde_query\": mde_query,\n            \"crowdstrike_query\": crowdstrike_query,\n            \"uptycs_query\": uptycs_query,\n        }\n    }]\nelse:\n    return [{\"json\": {\"message\": \"No IDs found\"}}]\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        -140
      ],
      "id": "bb23d25f-92a6-4518-8b94-268e6dca7c43",
      "name": "Domain Queries"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Extract all IDs from incoming items\nids = []\n\nfor item in items:\n    data = item.get(\"json\", {}).get(\"data\", {})\n    if \"id\" in data:\n        ids.append(data[\"id\"])\n\n# Generate queries if we have IDs\nif ids:\n    # ---------------------------\n    # Format for MDE (KQL)\n    id_list_kql = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    mde_query = f\"\"\"\nDeviceFileEvents\n| where SHA256 in ({id_list_kql})\n\"\"\"\n\n    # ---------------------------\n    # Format for CrowdStrike (Raptor)\n    id_list_crowdstrike = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    crowdstrike_query = f\"\"\"\n#event_simpleName=*FileWritten*\n| in(field=SHA256HashData, values=[{id_list_crowdstrike}])\n\"\"\"\n\n    # ---------------------------\n    # Format for Uptycs (SQL-like)\n    id_list_uptycs = \", \".join([f\"'{d}'\" for d in ids])\n    uptycs_query = f\"\"\"\nSELECT *\nFROM dns_lookup_events\nWHERE\nquestion IN ({id_list_uptycs})\nAND\nupt_day >= CAST(date_format((CURRENT_DATE - INTERVAL '14' DAY), '%Y%m%d') AS INT)\n\"\"\"\n\n    # Clean up queries (remove \\n, collapse into single lines)\n    mde_query = \" \".join(mde_query.split())\n    crowdstrike_query = \" \".join(crowdstrike_query.split())\n    uptycs_query = \" \".join(uptycs_query.split())\n\n    # Return queries back to n8n\n    return [{\n        \"json\": {\n            \"ids\": ids,\n            \"mde_query\": mde_query,\n            \"crowdstrike_query\": crowdstrike_query,\n            \"uptycs_query\": uptycs_query,\n        }\n    }]\nelse:\n    return [{\"json\": {\"message\": \"No IDs found\"}}]\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        0
      ],
      "id": "21682797-7c45-4c0d-a42a-752f5d6e096f",
      "name": "File Hash Queries"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Extract all IDs from incoming items\nids = []\n\nfor item in items:\n    data = item.get(\"json\", {}).get(\"data\", {})\n    if \"id\" in data:\n        ids.append(data[\"id\"])\n\n# Generate queries if we have IDs\nif ids:\n    # ---------------------------\n    # Format for MDE (KQL)\n    id_list_kql = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    mde_query = f\"\"\"\nDeviceNetworkEvents\n| where RemoteIP in ({id_list_kql})\n\"\"\"\n\n    # ---------------------------\n    # Format for CrowdStrike (Raptor)\n    id_list_crowdstrike = \", \".join([f\"\\\"{d}\\\"\" for d in ids])\n    crowdstrike_query = f\"\"\"\n#event_simpleName=\"NetworkConnectIP4\"\n| in(field=RemoteIP, values=[{id_list_crowdstrike}])\n\"\"\"\n\n    # ---------------------------\n    # Format for Uptycs (SQL-like)\n    id_list_uptycs = \", \".join([f\"'{d}'\" for d in ids])\n    uptycs_query = f\"\"\"\nSELECT *\nFROM http_events\nWHERE\nremote IN ({id_list_uptycs})\nAND\nupt_day >= CAST(date_format((CURRENT_DATE - INTERVAL '14' DAY), '%Y%m%d') AS INT)\n\"\"\"\n\n    # Clean up queries (remove \\n, collapse into single lines)\n    mde_query = \" \".join(mde_query.split())\n    crowdstrike_query = \" \".join(crowdstrike_query.split())\n    uptycs_query = \" \".join(uptycs_query.split())\n\n    # Return queries back to n8n\n    return [{\n        \"json\": {\n            \"ids\": ids,\n            \"mde_query\": mde_query,\n            \"crowdstrike_query\": crowdstrike_query,\n            \"uptycs_query\": uptycs_query,\n        }\n    }]\nelse:\n    return [{\"json\": {\"message\": \"No IDs found\"}}]\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        160
      ],
      "id": "a1f9bd8d-0b78-4557-b258-72353d0f238a",
      "name": "IP Queries"
    },
    {
      "parameters": {
        "modelName": "models/gemini-pro-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        740,
        -120
      ],
      "id": "cc60c5c4-7e59-4e8b-8356-205722a42ef0",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "DdsJpQitJYgSOzWT",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import json\n\n# Example: get raw text from input (n8n `items[0][\"json\"].get(\"text\", \"\")`)\nraw_text = \"\"\"\n\n\"\"\"\n\n# Escape special characters and convert to JSON\njson_object = {\"data\": raw_text}\n\n# Serialize safely\noutput = json.dumps(json_object, ensure_ascii=False)\n\n# In n8n, you need to return a dict\nreturn json.loads(output)\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        0
      ],
      "id": "8bf3d8c9-1e1a-41c6-a7e4-1dc868f360aa",
      "name": "Code"
    },
    {
      "parameters": {
        "modelName": "models/gemini-pro-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1320,
        -340
      ],
      "id": "4475ef5e-fd23-4e4d-92ca-2cf89741989c",
      "name": "Google Gemini Chat Model1"
    },
    {
      "parameters": {
        "operation": "toText",
        "sourceProperty": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        1660,
        -520
      ],
      "id": "d32da3db-45c9-4c51-aacd-b09b1e3a1d3e",
      "name": "Convert to File1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the report below and propose Sigma detection rules.\n\nRequirements:\n- Output ONLY valid YAML.\n- Wrap the ENTIRE YAML output inside triple backticks ```yaml\n- Include for each rule: title, logsource, detection, condition, tags (MITRE ATT&CK IDs).\n\nReport to analyze:\n{{ $json.cleaned_text }} {{ $json.data }}",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        720,
        -320
      ],
      "id": "25d1abea-fc4c-47f3-a1a9-21c8d73da64b",
      "name": "LLM Chain - Sigma Rules",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=From the sigma rules found below, translate each one into three different querying languages. One will be for KQL Kusto MDE querying language, the other for Raptor CrowdStrike querying language, and the final will be for Uptycs SQL querying language.\n\nHere are the sigma rules:\n {{ $json.text }}",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1300,
        -520
      ],
      "id": "425c12eb-817c-4a13-8680-1b2d0b67b344",
      "name": "LLM Chain - Translation Sigma to Query"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking â€˜Execute workflowâ€™": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "IOC Pattern Extraction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Beautify HTLM/Raw User Input",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "VirusTotal HTTP Request": {
      "main": [
        [
          {
            "node": "Domain Enrichment -  Malicious Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VirusTotal HTTP Request1": {
      "main": [
        [
          {
            "node": "File Hash Enrichment -  Malicious Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VirusTotal HTTP Request2": {
      "main": [
        [
          {
            "node": "IP Enrichment -  Malicious Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Beautify HTLM/Raw User Input": {
      "main": [
        [
          {
            "node": "LLM Chain - Sigma Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IOC Pattern Extraction": {
      "main": [
        [
          {
            "node": "IOC CleanUp",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IOC CleanUp": {
      "main": [
        [
          {
            "node": "Switch - Domains, File Hashes, IPs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch - Domains, File Hashes, IPs": {
      "main": [
        [
          {
            "node": "VirusTotal HTTP Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "VirusTotal HTTP Request1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "VirusTotal HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Domain Enrichment -  Malicious Output": {
      "main": [
        [
          {
            "node": "Domain Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Hash Enrichment -  Malicious Output": {
      "main": [
        [
          {
            "node": "File Hash Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IP Enrichment -  Malicious Output": {
      "main": [
        [
          {
            "node": "IP Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Hash Queries": {
      "main": [
        []
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain - Sigma Rules",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "LLM Chain - Sigma Rules",
            "type": "main",
            "index": 0
          },
          {
            "node": "IOC Pattern Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain - Translation Sigma to Query",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain - Sigma Rules": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          },
          {
            "node": "LLM Chain - Translation Sigma to Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain - Translation Sigma to Query": {
      "main": [
        [
          {
            "node": "Convert to File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "3322a168-7937-4b23-b827-d9b53fba476f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "13d01de745dc8b9f7fd3336bee17fafc85c39152ae5ea76ff367d1a4981aa787"
  },
  "id": "0M4w2D44ZL0gDmqt",
  "tags": []
}